From 73d203c116777249ae37ffdc01eb539e3b1423ed Mon Sep 17 00:00:00 2001
From: "Richard W.M. Jones" <rjones@redhat.com>
Date: Fri, 11 Nov 2011 11:01:46 +0000
Subject: [PATCH 01/10] New API: mdadm-create for creating MD devices. (cherry
 picked from commit
 c11a92751e003b3d4bc3584b598afc9bd9d9e703)

---
 daemon/Makefile.am             |    1 +
 daemon/md.c                    |  170 ++++++++++++++++++++++++++++++++++++++++
 generator/generator_actions.ml |   58 ++++++++++++++
 po/POTFILES.in                 |    1 +
 regressions/Makefile.am        |    1 +
 regressions/test-mdadm.sh      |   95 ++++++++++++++++++++++
 src/MAX_PROC_NR                |    2 +-
 7 files changed, 327 insertions(+), 1 deletions(-)
 create mode 100644 daemon/md.c
 create mode 100755 regressions/test-mdadm.sh

diff --git a/daemon/Makefile.am b/daemon/Makefile.am
index e071cc8..a19a157 100644
--- a/daemon/Makefile.am
+++ b/daemon/Makefile.am
@@ -129,6 +129,7 @@ guestfsd_SOURCES = \
 	luks.c \
 	lvm.c \
 	lvm-filter.c \
+	md.c \
 	mkfs.c \
 	mknod.c \
 	modprobe.c \
diff --git a/daemon/md.c b/daemon/md.c
new file mode 100644
index 0000000..1adb4ac
--- /dev/null
+++ b/daemon/md.c
@@ -0,0 +1,170 @@
+/* libguestfs - the guestfsd daemon
+ * Copyright (C) 2011 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include <glob.h>
+
+#include "daemon.h"
+#include "actions.h"
+#include "optgroups.h"
+
+int
+optgroup_mdadm_available (void)
+{
+  return prog_exists ("mdadm");
+}
+
+static size_t
+count_bits (uint64_t bitmap)
+{
+  size_t c;
+
+  if (bitmap == 0)
+    return 0;
+
+  c = bitmap & 1 ? 1 : 0;
+  bitmap >>= 1;
+  return c + count_bits (bitmap);
+}
+
+/* Takes optional arguments, consult optargs_bitmask. */
+int
+do_mdadm_create (const char *name, char *const *devices,
+                 int64_t missingbitmap, int nrdevices, int spare,
+                 int64_t chunk, const char *level)
+{
+  char nrdevices_s[32];
+  char spare_s[32];
+  char chunk_s[32];
+  size_t j;
+  int r;
+  char *err;
+  uint64_t umissingbitmap = (uint64_t) missingbitmap;
+
+  /* Check the optional parameters and set defaults where appropriate. */
+  if (!(optargs_bitmask & GUESTFS_MDADM_CREATE_MISSINGBITMAP_BITMASK))
+    umissingbitmap = 0;
+
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_SPARE_BITMASK) {
+    if (spare < 0) {
+      reply_with_error ("spare must not be negative");
+      return -1;
+    }
+  }
+  else
+    spare = 0;
+
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_NRDEVICES_BITMASK) {
+    if (nrdevices < 2) {
+      reply_with_error ("nrdevices is less than 2");
+      return -1;
+    }
+  }
+  else
+    nrdevices = count_strings (devices) + count_bits (umissingbitmap);
+
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_LEVEL_BITMASK) {
+    if (STRNEQ (level, "linear") && STRNEQ (level, "raid0") &&
+        STRNEQ (level, "0") && STRNEQ (level, "stripe") &&
+        STRNEQ (level, "raid1") && STRNEQ (level, "1") &&
+        STRNEQ (level, "mirror") &&
+        STRNEQ (level, "raid4") && STRNEQ (level, "4") &&
+        STRNEQ (level, "raid5") && STRNEQ (level, "5") &&
+        STRNEQ (level, "raid6") && STRNEQ (level, "6") &&
+        STRNEQ (level, "raid10") && STRNEQ (level, "10")) {
+      reply_with_error ("unknown level parameter: %s", level);
+      return -1;
+    }
+  }
+  else
+    level = "raid1";
+
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_CHUNK_BITMASK) {
+    /* chunk is bytes in the libguestfs API, but K when we pass it to mdadm */
+    if ((chunk & 1023) != 0) {
+      reply_with_error ("chunk size must be a multiple of 1024 bytes");
+      return -1;
+    }
+  }
+
+  /* Check invariant. */
+  if (count_strings (devices) + count_bits (umissingbitmap) !=
+      (size_t) (nrdevices + spare)) {
+    reply_with_error ("devices (%zu) + bits set in missingbitmap (%zu) is not equal to nrdevices (%d) + spare (%d)",
+                      count_strings (devices), count_bits (umissingbitmap),
+                      nrdevices, spare);
+    return -1;
+  }
+
+  size_t MAX_ARGS = nrdevices + 16;
+  const char *argv[MAX_ARGS];
+  size_t i = 0;
+
+  ADD_ARG (argv, i, "mdadm");
+  ADD_ARG (argv, i, "--create");
+  /* --run suppresses "Continue creating array" question */
+  ADD_ARG (argv, i, "--run");
+  ADD_ARG (argv, i, name);
+  ADD_ARG (argv, i, "--level");
+  ADD_ARG (argv, i, level);
+  ADD_ARG (argv, i, "--raid-devices");
+  snprintf (nrdevices_s, sizeof nrdevices_s, "%d", nrdevices);
+  ADD_ARG (argv, i, nrdevices_s);
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_SPARE_BITMASK) {
+    ADD_ARG (argv, i, "--spare-devices");
+    snprintf (spare_s, sizeof spare_s, "%d", spare);
+    ADD_ARG (argv, i, spare_s);
+  }
+  if (optargs_bitmask & GUESTFS_MDADM_CREATE_CHUNK_BITMASK) {
+    ADD_ARG (argv, i, "--chunk");
+    snprintf (chunk_s, sizeof chunk_s, "%" PRIi64, chunk / 1024);
+    ADD_ARG (argv, i, chunk_s);
+  }
+
+  /* Add devices and "missing". */
+  j = 0;
+  while (devices[j] != NULL || umissingbitmap != 0) {
+    if (umissingbitmap & 1)
+      ADD_ARG (argv, i, "missing");
+    else {
+      ADD_ARG (argv, i, devices[j]);
+      j++;
+    }
+    umissingbitmap >>= 1;
+  }
+
+  ADD_ARG (argv, i, NULL);
+
+  r = commandv (NULL, &err, argv);
+  if (r == -1) {
+    reply_with_error ("mdadm: %s: %s", name, err);
+    free (err);
+    return -1;
+  }
+
+  free (err);
+
+  udev_settle ();
+
+  return 0;
+}
diff --git a/generator/generator_actions.ml b/generator/generator_actions.ml
index d3fa3e0..80814f5 100644
--- a/generator/generator_actions.ml
+++ b/generator/generator_actions.ml
@@ -6332,6 +6332,64 @@ is for copying blocks within existing files.  See C<guestfs_cp>,
 C<guestfs_cp_a> and C<guestfs_mv> for general file copying and
 moving functions.");
 
+  ("mdadm_create", (RErr, [String "name"; DeviceList "devices"], [Int64 "missingbitmap"; Int "nrdevices"; Int "spare"; Int64 "chunk"; String "level"]), 299, [Optional "mdadm"],
+   [],
+   "create a Linux md (RAID) device",
+   "\
+Create a Linux md (RAID) device named C<name> on the devices
+in the list C<devices>.
+
+The optional parameters are:
+
+=over 4
+
+=item C<missingbitmap>
+
+A bitmap of missing devices.  If a bit is set it means that a
+missing device is added to the array.  The least significant bit
+corresponds to the first device in the array.
+
+As examples:
+
+If C<devices = [\"/dev/sda\"]> and C<missingbitmap = 0x1> then
+the resulting array would be C<[E<lt>missingE<gt>, \"/dev/sda\"]>.
+
+If C<devices = [\"/dev/sda\"]> and C<missingbitmap = 0x2> then
+the resulting array would be C<[\"/dev/sda\", E<lt>missingE<gt>]>.
+
+This defaults to C<0> (no missing devices).
+
+The length of C<devices> + the number of bits set in
+C<missingbitmap> must equal C<nrdevices> + C<spare>.
+
+=item C<nrdevices>
+
+The number of active RAID devices.
+
+If not set, this defaults to the length of C<devices> plus
+the number of bits set in C<missingbitmap>.
+
+=item C<spare>
+
+The number of spare devices.
+
+If not set, this defaults to C<0>.
+
+=item C<chunk>
+
+The chunk size in bytes.
+
+=item C<level>
+
+The RAID level, which can be one of:
+I<linear>, I<raid0>, I<0>, I<stripe>, I<raid1>, I<1>, I<mirror>,
+I<raid4>, I<4>, I<raid5>, I<5>, I<raid6>, I<6>, I<raid10>, I<10>.
+Some of these are synonymous, and more levels may be added in future.
+
+If not set, this defaults to C<raid1>.
+
+=back");
+
 ]
 
 let all_functions = non_daemon_functions @ daemon_functions
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 0ed9e45..fcc612d 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -48,6 +48,7 @@ daemon/ls.c
 daemon/luks.c
 daemon/lvm-filter.c
 daemon/lvm.c
+daemon/md.c
 daemon/mkfs.c
 daemon/mknod.c
 daemon/modprobe.c
diff --git a/regressions/Makefile.am b/regressions/Makefile.am
index 0af7e8c..5263905 100644
--- a/regressions/Makefile.am
+++ b/regressions/Makefile.am
@@ -49,6 +49,7 @@ TESTS = \
 	test-luks-list.sh \
 	test-lvm-filtering.sh \
 	test-lvm-mapping.pl \
+	test-mdadm.sh \
 	test-noexec-stack.pl \
 	test-qemudie-killsub.sh \
 	test-qemudie-midcommand.sh \
diff --git a/regressions/test-mdadm.sh b/regressions/test-mdadm.sh
new file mode 100755
index 0000000..3ad4f22
--- /dev/null
+++ b/regressions/test-mdadm.sh
@@ -0,0 +1,95 @@
+#!/bin/bash -
+# libguestfs
+# Copyright (C) 2011 Red Hat Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+# Test guestfish mdadm-create command.
+
+set -e
+
+rm -f md-test1.img md-test2.img md-test3.img md-test4.img
+
+../fish/guestfish <<EOF
+# Add four empty disks
+sparse md-test1.img 100M
+sparse md-test2.img 100M
+sparse md-test3.img 100M
+sparse md-test4.img 100M
+run
+
+# Create lots of test partitions.
+part-init /dev/sda mbr
+part-add /dev/sda p 4096 8191
+part-add /dev/sda p 8192 12287
+part-add /dev/sda p 12288 16383
+part-add /dev/sda p 16384 20479
+part-init /dev/sdb mbr
+part-add /dev/sdb p 4096 8191
+part-add /dev/sdb p 8192 12287
+part-add /dev/sdb p 12288 16383
+part-add /dev/sdb p 16384 20479
+part-init /dev/sdc mbr
+part-add /dev/sdc p 4096 8191
+part-add /dev/sdc p 8192 12287
+part-add /dev/sdc p 12288 16383
+part-add /dev/sdc p 16384 20479
+part-init /dev/sdd mbr
+part-add /dev/sdd p 4096 8191
+part-add /dev/sdd p 8192 12287
+part-add /dev/sdd p 12288 16383
+part-add /dev/sdd p 16384 20479
+
+# RAID 1.
+mdadm-create r1t1 "/dev/sda1 /dev/sdb1"
+mdadm-create r1t2 "/dev/sdc1 /dev/sdd1" chunk:65536
+
+# RAID 5.
+mdadm-create r5t1 "/dev/sda2 /dev/sdb2 /dev/sdc2 /dev/sdd2" \
+  missingbitmap:0x10 nrdevices:4 spare:1 level:5
+
+mdadm-create r5t2 "/dev/sda3 /dev/sdb3" missingbitmap:0x1 level:5
+
+mdadm-create r5t3 "/dev/sdc3 /dev/sdd3" \
+  missingbitmap:0x6 nrdevices:2 spare:2 level:5
+
+# Make some filesystems and put some content on the
+# new RAID devices to see if they work.
+mkfs ext2 /dev/md/r1t1
+mkfs ext2 /dev/md/r1t2
+mkfs ext2 /dev/md/r5t1
+mkfs ext2 /dev/md/r5t2
+mkfs ext2 /dev/md/r5t3
+
+mkmountpoint /r1t1
+mount /dev/md/r1t1 /r1t1
+mkmountpoint /r1t2
+mount /dev/md/r1t2 /r1t2
+mkmountpoint /r5t1
+mount /dev/md/r5t1 /r5t1
+mkmountpoint /r5t2
+mount /dev/md/r5t2 /r5t2
+mkmountpoint /r5t3
+mount /dev/md/r5t3 /r5t3
+
+touch /r1t1/foo
+mkdir /r1t2/bar
+write /r5t1/foo "hello"
+write /r5t2/bar "goodbye"
+write /r5t3/baz "testing"
+
+EOF
+
+rm -f md-test1.img md-test2.img md-test3.img md-test4.img
diff --git a/src/MAX_PROC_NR b/src/MAX_PROC_NR
index 95de1ee..03a5b41 100644
--- a/src/MAX_PROC_NR
+++ b/src/MAX_PROC_NR
@@ -1 +1 @@
-297
+299
-- 
1.7.6

